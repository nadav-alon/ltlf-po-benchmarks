random_literal() {
	if (( $RANDOM % 2 == 1 ))
	then
		echo -n "true"
	else
		if (( $RANDOM % 2 == 1 ))
		then
			echo -n "$1"
		else
			echo -n "!$1"
		fi
	fi
}

n=$1
m=$2

generate_game_formula() {
	player=$1

	for i in $(seq 0 $((m-1)))
	do
		echo -e -n "\t\tG(peek_${player}[${i}] <-> "

		random_literal "plate_env[0]"
		echo -n " && "
		random_literal "plate_sys[0]"

		for j in $(seq 1 $((n-1)))
		do
			echo -n " && "
			random_literal "plate_env[${j}]"
			echo -n " && "
			random_literal "plate_sys[${j}]"
		done

		echo ");"
	done
}

cat << EOF
INFO
{
	TITLE: "Peek with ${n} plates and ${m} holes per player"
	DESCRIPTION: "Peek"
	SEMANTICS: Moore
	TARGET: Moore
}

GLOBAL
{
	PARAMETERS
	{
		n = ${n}; // number of plates per player
		m = ${m}; // number of holes per player
	}

	DEFINITIONS
	{
		change(p) = (X p <-> !p);
	}
}

MAIN
{
	INPUTS
	{
		plate_env[n]; // 1 if the environment's ith plate is in

		// Environment is responsible for updating the holes since the
		// system doesn't have enough information to do it.
		peek_env[m]; // 1 if environment can peek through its ith hole
		peek_sys[m]; // 1 if system can peek through its ith hole
	}

	OUTPUTS
	{
		turn_env; // 1 if it's environment player's turn
		turn_sys; // 1 if it's system player's turn
		plate_sys[n]; // 1 if the system's ith plate is in
	}

	ASSUME
	{
		// Initially all environment plates are in
		&&[0 <= i < n] plate_env[i];

		// On the environment's turn, it can move at most one plate
		&&[0 <= i < n] &&[i < j < n] G(X turn_env -> (change(plate_env[i]) -> !change(plate_env[j])));

		// If it's not the environment's turn, it cannot move any plates
		&&[0 <= i < n] G(X !turn_env -> !change(plate_env[i]));

		// Encoding of the holes in DNF
EOF

generate_game_formula "env"
generate_game_formula "sys"

cat << EOF
	}

	GUARANTEE
	{
		// First timestep is setup, neither player moves
		!turn_sys;
		!turn_env;

		// Initially all system plates are in
		&&[0 <= i < n] plate_sys[i];

		// System is the first player to move
		X turn_sys;

		// Only one player can move at a time
		X G(turn_sys <-> !turn_env);

		// Players alternate turns
		X G(X true -> (X turn_sys <-> turn_env));

		// On the system's turn, it can move at most one plate
		&&[0 <= i < n] &&[i < j < n] G(X turn_sys -> (change(plate_sys[i]) -> !change(plate_sys[j])));

		// If it's not the system's turn, it cannot move any plates
		&&[0 <= i < n] G(X !turn_sys -> !change(plate_sys[i]));

		// System wins if it can peek through one of its holes before the environment
		(&&[0 <= i < m] (turn_env -> !peek_env[i])) U (turn_sys && ||[0 <= i < m] peek_sys[i]);

	}
}
EOF
